import { error, getCarbonServiceRole, success } from "@carbon/auth";
import { requirePermissions } from "@carbon/auth/auth.server";
import { flash } from "@carbon/auth/session.server";
import { FunctionRegion } from "@supabase/supabase-js";
import { redirect, type LoaderFunctionArgs } from "@vercel/remix";
import {
  finishJobOperation,
  getTrackedEntitiesByMakeMethodId,
  insertProductionQuantity
} from "~/services/operations.service";
import { path } from "~/utils/path";

export async function loader({ request, params }: LoaderFunctionArgs) {
  const { userId, companyId } = await requirePermissions(request, {});

  const { operationId } = params;
  if (!operationId) throw new Error("Operation ID is required");

  const url = new URL(request.url);
  let trackedEntityId = url.searchParams.get("trackedEntityId");
  const serviceRole = await getCarbonServiceRole();

  const [jobOperation, productionQuantities] = await Promise.all([
    serviceRole
      .from("jobOperation")
      .select("*, ...process(completeAllOnScan)")
      .eq("id", operationId)
      .maybeSingle(),
    serviceRole
      .from("productionQuantity")
      .select("*")
      .eq("type", "Production")
      .eq("jobOperationId", operationId)
  ]);

  if (
    jobOperation.error ||
    !jobOperation.data ||
    !jobOperation.data.jobMakeMethodId
  ) {
    return redirect(
      path.to.operations,
      await flash(request, {
        ...error(jobOperation.error, "Failed to fetch job operation"),
        flash: "error"
      })
    );
  }

  if (jobOperation.data?.companyId !== companyId) {
    return redirect(
      path.to.operations,
      await flash(request, {
        ...error(
          "You are not authorized to start this operation",
          "Unauthorized"
        ),
        flash: "error"
      })
    );
  }
  const completeAll = jobOperation.data?.completeAllOnScan ?? false;

  const [jobMakeMethod] = await Promise.all([
    serviceRole
      .from("jobMakeMethod")
      .select("*")
      .eq("id", jobOperation.data.jobMakeMethodId)
      .maybeSingle()
  ]);

  if (jobMakeMethod.error || !jobMakeMethod.data) {
    return redirect(
      path.to.operations,
      await flash(
        request,
        error(jobMakeMethod.error, "Failed to fetch job make method")
      )
    );
  }

  const currentQuantity =
    productionQuantities.data?.reduce((acc, curr) => acc + curr.quantity, 0) ??
    0;

  const quantityToComplete = completeAll
    ? Math.max(0, (jobOperation.data.operationQuantity ?? 0) - currentQuantity)
    : 1;

  const willBeFinished =
    quantityToComplete + currentQuantity >=
    (jobOperation.data.operationQuantity ?? 0);

  const isTrackedEntity =
    jobMakeMethod.data.requiresSerialTracking ||
    jobMakeMethod.data.requiresBatchTracking;

  if (quantityToComplete > 0) {
    if (isTrackedEntity) {
      if (!trackedEntityId) {
        const trackedEntities = await getTrackedEntitiesByMakeMethodId(
          serviceRole,
          jobOperation.data.jobMakeMethodId
        );

        if (trackedEntities.data && trackedEntities.data.length > 0) {
          trackedEntityId =
            trackedEntities.data[trackedEntities.data.length - 1].id;
        }
      }

      if (jobMakeMethod.data.requiresSerialTracking) {
        const response = await serviceRole.functions.invoke("issue", {
          body: {
            type: "jobOperationSerialComplete",
            quantity: 1,
            jobOperationId: jobOperation.data.id,
            trackedEntityId,
            trackingType: "Serial",
            notes: "Generated by QR code",
            companyId,
            userId
          },
          region: FunctionRegion.UsEast1
        });

        const newTrackedEntityId = response.data?.newTrackedEntityId;

        if (newTrackedEntityId) {
          return redirect(
            `${path.to.operation(
              operationId
            )}?trackedEntityId=${newTrackedEntityId}`
          );
        }

        if (willBeFinished) {
          const finishOperation = await finishJobOperation(serviceRole, {
            jobOperationId: jobOperation.data.id,
            userId
          });

          if (finishOperation.error) {
            return redirect(
              path.to.operation(operationId),
              await flash(
                request,
                error(finishOperation.error, "Failed to finish operation")
              )
            );
          }

          return redirect(
            path.to.operations,
            await flash(request, {
              ...success("Operation finished successfully"),
              flash: "success"
            })
          );
        }
      } else if (jobMakeMethod.data.requiresBatchTracking) {
        const response = await serviceRole.functions.invoke("issue", {
          body: {
            type: "jobOperationBatchComplete",
            quantity: quantityToComplete,
            jobOperationId: jobOperation.data.id,
            trackedEntityId,
            trackingType: "Batch",
            notes: "Generated by QR code",
            companyId,
            userId
          },
          region: FunctionRegion.UsEast1
        });

        if (response.error) {
          return redirect(
            path.to.operation(operationId),
            await flash(request, {
              ...error(response.error, "Failed to complete job operation"),
              flash: "error"
            })
          );
        }
      }
    } else {
      const insertProduction = await insertProductionQuantity(serviceRole, {
        quantity: quantityToComplete,
        jobOperationId: jobOperation.data.id,
        notes: "Generated by QR code",
        companyId,
        createdBy: userId
      });

      if (insertProduction.error) {
        return redirect(
          path.to.operation(operationId),
          await flash(request, {
            ...error(
              insertProduction.error,
              "Failed to record production quantity"
            ),
            flash: "error"
          })
        );
      }

      const issue = await serviceRole.functions.invoke("issue", {
        body: {
          id: operationId,
          type: "jobOperation",
          quantity: quantityToComplete,
          companyId,
          userId
        },
        region: FunctionRegion.UsEast1
      });

      if (issue.error) {
        return redirect(
          path.to.operation(operationId),
          await flash(request, {
            ...error(issue.error, "Failed to issue materials"),
            flash: "error"
          })
        );
      }
    }
  }

  if (willBeFinished) {
    const finishOperation = await finishJobOperation(serviceRole, {
      jobOperationId: jobOperation.data.id,
      userId
    });

    if (finishOperation.error) {
      return redirect(
        path.to.operation(operationId),
        await flash(request, {
          ...error(finishOperation.error, "Failed to finish operation"),
          flash: "error"
        })
      );
    }

    return redirect(
      path.to.operations,
      await flash(request, {
        ...success("Operation finished successfully"),
        flash: "success"
      })
    );
  }

  return redirect(
    path.to.operation(operationId),
    await flash(request, {
      ...success("Successfully completed part"),
      flash: "success"
    })
  );
}
